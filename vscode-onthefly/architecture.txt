VS Code Extension Architecture
==============================

The VS Code package under `vscode-onthefly/` is the desktop front-end for the
Python runtime. It is split into a thin activation layer (`extension.ts`), a
cohesive extension host (`src/extensionHost/…`), a local SQLite adapter
(`storage.ts`), and the dashboard webview (`src/webview/`). Each piece can evolve
independently: the host focuses on IPC + state, the storage layer persists run
metadata, and the webview renders charts/logs.

Top-Level Layout
----------------
- **`src/extension.ts`** – VS Code entry point. Registers the dashboard command,
  manages the webview panel lifecycle, forwards webview messages into the host,
  and coordinates session resets.
- **`src/storage.ts`** – Typed wrapper around the SQLite database (shared with
  Python). Provides helpers for inserting runs, metrics, checkpoints, logs, and
  exporting/importing bundles.
- **`src/extensionHost/`**
  - `ipc.ts` encapsulates the TCP server that accepts trainer connections,
    manages JSON-RPC calls to the Python process, handles streaming events, and
    exposes helpers such as `ensureTrainerOnRun`, `runHealth`, and
    `requestBackendPause`.
  - `state.ts` owns every mutable bit of runtime state (current run, session ID,
    pending pause/resume flags) plus the `post`/`postStatus` utilities for
    messaging the webview.
  - `types.ts` centralizes the union types for webview commands (`WebMsg`),
    outgoing control messages (`Ctl`), and shared data structures (`StepRow`,
    `TrainerResetSeed`, etc.).
- **`src/webview/`** – Static JS/HTML bundle loaded inside the dashboard. It
  consumes the extension messages (`post(...)`) to render charts, logs, DAGs, and
  health diagnostics.

Activation Flow
---------------
1. **Activation** – VS Code calls `activate` in `extension.ts`. The file registers
   the `onthefly.showDashboard` command, rehydrates existing panels, and calls
   `initStorage` to prepare the local DB.
2. **Panel creation** – `openPanel` (or `revivePanel`) instantiates the dashboard
   webview, injects resource URIs for the JS bundle, and wires `onDidReceiveMessage`
   so UI events are routed to `onMessage`.
3. **Trainer lifecycle** – The first panel/configuration call invokes
   `ensureTrainerServer()` inside `extensionHost/ipc.ts`, which starts a TCP
   server on `localhost`. When a Python trainer connects, `ipc.ts`:
   - Clears pending RPC promises.
   - Emits `status`/`log` updates to the webview via `post`.
   - Seeds the trainer with the current run context (fork/merge counters,
     checkpoint hints) using `seedTrainerForRun`.
   - Streams back `trainStep`, `log`, and other events, persisting them through
     `storage.ts` as needed.
4. **Webview commands** – UI actions (pause/resume, fork/merge, exports, health
   checks, etc.) arrive as `WebMsg` unions defined in `types.ts`. `extension.ts`
   handles each command by combining host helpers and storage APIs. Examples:
   - `pause` → `requestBackendPause` + checkpoint insert.
   - `resume` → `resumeTrainerOn` or `resumeAfterReset`.
   - `exportSubset` → gather indices from UI/storage, then call
     `sendReq('export_subset', …)`.
   - `generateReport` → uses stored subsets, executes the RPC, and persists the
     loss distribution.
5. **Storage + bundles** – Export/import commands call `storageExportBundle` and
   `storageLoadBundle` to move the SQLite DB and referenced checkpoints on/off
   disk. During exports, the host requests the Python process to spill the latest
   checkpoints (`prepare_export` or `spill_all`) so the bundle is complete.

Communication Channels
----------------------
- **Extension ↔ Webview** – `post(...)` in `state.ts` sends messages to the UI.
  The panel registers a single `onDidReceiveMessage` handler that forwards
  everything to `onMessage`.
- **Extension ↔ Python Trainer** – `ipc.ts` manages a newline-delimited JSON
  protocol. Outgoing requests include an `id`; responses resolve/reject pending
  promises stored in `ipc.ts`. Streaming events (train/log/test) are emitted to
  the webview and persisted through `storage.ts`.
- **Extension ↔ SQLite** – `storage.ts` offers synchronous helpers (using
  `better-sqlite3`) so the activation thread can insert metrics/logs without
  additional IPC. The module also exposes analytical queries (runs, sessions,
  logs by phase) that the webview polls for.

State Management
----------------
The host maintains all mutable state in `extensionHost/state.ts`. Key fields:
- `panel` – active webview panel reference (or null when closed).
- `currentRunId` / `modelNavSelectedRunId` – drive status updates and informs
  which run to resume/pause.
- `currentSessionId` – tags logs, drives grouped log fetches, and helps detect
  whether a run was created in the current trainer session
  (`nativeRunsThisSession` Set).
- `pauseInFlight` / `resumeInFlight` / `pendingResumeAwaitingFirstRun` – ensure
  that user actions don't double-submit RPCs when a trainer is busy.
`state.ts` also exposes `postStatus` to keep the UI icons honest whenever run
activity changes.

Event Handling Pipeline
-----------------------
1. The Python trainer sends an event (e.g., `{"type":"trainStep",…}`).
2. `ipc.ts` parses the line, updates `extensionState.currentRunId` if necessary,
   persists the data through `storage.ts`, and emits user-facing events via
   `post({ type: 'trainStep', … })`.
3. Certain event types trigger additional logic:
   - `newRun` → ensures the run exists in SQLite, updates session IDs, and emits
     `runs` so the UI refreshes the run list.
   - `log` → heuristically infers the phase (train/test/info) and filters out
     redundant `step` badges before posting to the UI.
   - `session_started` → optionally calls the Python `clean_disk` RPC on first
     connect to remove stale checkpoints.

Adding Features
---------------
- **New dashboard command** – add a union member to `WebMsg` (`types.ts`), handle
  it inside `extension.ts:onMessage`, and (if needed) add IPC/storage helpers.
- **New trainer RPC** – define the request/response logic in `ipc.ts` (using
  `sendReq`) and expose a typed helper so `extension.ts` can call it.
- **New persistence** – extend `storage.ts` with the required SQL, import the
  helper into `extension.ts`, and call it from the appropriate event handler.
- **New UI bundle assets** – drop files into `src/webview/` and register them in
  `getHtml` (extension.ts) so the panel can load them via `webview.asWebviewUri`.

Because the host/state/IPC modules are now isolated, modifying trainer messaging
or storage logic no longer requires editing the large activation file. The
extension remains responsive by keeping heavy work (RPC waits, exports) inside
`withProgress` blocks while the UI and trainer stay in sync via the shared state.
